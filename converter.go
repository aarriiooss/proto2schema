package main

import (
	"context"
	"fmt"
	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"log"
	"os"
	"strings"
)

const protoIndexKey = iota

type protoPath []int32

type messageIndexMetadata struct {
	// proto descriptor of the message which contains fields etc
	descriptor *descriptorpb.DescriptorProto

	// file descriptor of the file this message belongs to
	// useful for picking out comments or anything else we can't get at the message level
	fileDescriptor *descriptorpb.FileDescriptorProto

	// path of this field in sourceInfo from fileDescriptor
	path protoPath

	// key in parent map - is this needed?
	key string
}

type enumIndexMetadata struct {
	// proto descriptor for enum - maybe union type in the future?
	descriptor *descriptorpb.EnumDescriptorProto

	// file descriptor of the file this message belongs to
	// useful for picking out comments or anything else we can't get at the message level
	fileDescriptor *descriptorpb.FileDescriptorProto

	// path of this field in sourceInfo from fileDescriptor
	path protoPath

	// key in parent map - is this needed?
	key string
}

type protoPathIndexType map[string]protoPath
type messageIndexType map[string]*descriptorpb.DescriptorProto
type enumIndexType map[string]*descriptorpb.EnumDescriptorProto

type protoIndex struct {
	messageIndex map[string]*messageIndexMetadata
	enumIndex    map[string]*enumIndexMetadata
}

type msgOrEnumType interface {
	*descriptorpb.DescriptorProto | *descriptorpb.EnumDescriptorProto
}

func (p protoIndex) addMessage(key string, path protoPath, file *descriptorpb.FileDescriptorProto, message *descriptorpb.DescriptorProto) {
	if _, ok := p.messageIndex[key]; !ok {
		p.messageIndex[key] = &messageIndexMetadata{
			//descriptor: message,
			//fileDescriptor: file,
			//path: path,
			//key: key,
		}
	}
	p.messageIndex[key].descriptor = message
	p.messageIndex[key].fileDescriptor = file
	p.messageIndex[key].path = path
	p.messageIndex[key].key = key
}

func (p protoIndex) fetchMetadata(key string) {}

func (p protoIndex) fetchComment(key string) string {
	//var metadata any
	//if _, ok := p.messageIndex[key]; !ok {
	//	if _, ok := p.enumIndex[key]; !ok {
	//		return "KEY NOT FOUND!"
	//	} else {
	//		metadata = p.enumIndex[key]
	//		metadata = metadata.(*enumIndexMetadata)
	//	}
	//} else {
	//	metadata = p.messageIndex[key]
	//	metadata = metadata.(*messageIndexMetadata)
	//}
	//
	//sourceLocation := metadata.fileDescriptor.Location
	//
	//for _, loc := range sourceInfo.Location {
	//	if equalPath(loc.Path, path) {
	//		comment := strings.TrimSpace(loc.GetLeadingComments())
	//		if comment == "" {
	//			comment = strings.TrimSpace(loc.GetTrailingComments())
	//		}
	//		return comment
	//	}
	//}
	//return ""
	return ""
}

func (p protoIndex) addEnum(key string, path protoPath, file *descriptorpb.FileDescriptorProto, message *descriptorpb.EnumDescriptorProto) {
	if _, ok := p.enumIndex[key]; !ok {
		p.enumIndex[key] = &enumIndexMetadata{}
	}
	p.enumIndex[key].descriptor = message
	p.enumIndex[key].fileDescriptor = file
	p.enumIndex[key].key = key
	p.enumIndex[key].path = path
}

func newProtoIndex() *protoIndex {
	return &protoIndex{
		messageIndex: make(map[string]*messageIndexMetadata),
		enumIndex:    make(map[string]*enumIndexMetadata),
	}
}

// Global maps to resolve message and enum definitions by fully-qualified name.
var messageIndex = make(messageIndexType)
var enumIndex = make(enumIndexType)
var protoPathIndex = make(protoPathIndexType)

// For simplicity, assume all definitions come from one file.
//var sourceInfo *descriptorpb.SourceCodeInfo

func main() {
	descriptorPath := "gen/addressbook.binpb"
	fdhSchemaPath := "gen/addressbook.fdhschema"

	pIndex := newProtoIndex()
	ctx := context.WithValue(context.TODO(), protoIndexKey, pIndex)

	log.Println("Attempting to read binbp")
	// Read the file descriptor set generated by protoc.
	data, err := os.ReadFile(descriptorPath)
	if err != nil {
		log.Fatalf("Failed to read descriptor set: %v", err)
	}
	log.Printf("Read descriptor set: %s", descriptorPath)

	// Unmarshal the data into a FileDescriptorSet.
	var fds descriptorpb.FileDescriptorSet
	if err := proto.Unmarshal(data, &fds); err != nil {
		log.Fatalf("Failed to unmarshal descriptor set: %v", err)
	}
	log.Println("Unmarshalled descriptor set.")

	for _, file := range fds.File {
		packageName := "." + file.GetPackage()

		// Build lookup maps for top-level messages and enums.
		for i, msg := range file.MessageType {
			fqName := packageName + "." + msg.GetName()
			messageIndex[fqName] = msg
			topMsgPath := protoPath{4, int32(i)}
			pIndex.addMessage(fqName, topMsgPath, file, msg)
			protoPathIndex[fqName] = topMsgPath
			//indexNestedMessages(fqName, msg, file, topMsgPath, pIndex)
			indexNestedMessages(ctx, fqName)

		}
		for i, enum := range file.EnumType {
			fqName := packageName + "." + enum.GetName()
			enumIndex[fqName] = enum
			enumPath := protoPath{5, int32(i)}
			protoPathIndex[fqName] = enumPath
			pIndex.addEnum(fqName, enumPath, file, enum)
		}
	}

	log.Println("finish parsing descriptor set.")
	// Create or open the output file.
	outFile, err := os.Create(fdhSchemaPath)
	if err != nil {
		log.Fatalf("Failed to create output file: %v", err)
	}
	defer func(outFile *os.File) {
		err := outFile.Close()
		if err != nil {

		}
	}(outFile)

	for _, ep := range findEntrypoints() {
		if _, ok := pIndex.messageIndex[ep]; ok {
			//entryPoint := entryPointMetadata.descriptor
			//entryPointPath := entryPointMetadata.path
			printMessage(ctx, outFile, ep, 0)
			//if entryPointPath, ok := protoPathIndex[ep]; ok {
			//	printMessage(outFile, entryPoint, entryPointPath, 0)
			//} else {
			//	log.Println("Failed to find path for entrypoint")
			//}

			//fmt.Fprintf(outFile, "\n")
		}
	}

}

func printCommentIfAny(outFile *os.File, fileDescriptor *descriptorpb.FileDescriptorProto, path protoPath, level int) {
	// remove comments from google fields as they are quite long
	if strings.HasPrefix(fileDescriptor.GetPackage(), "google.") == true {
		return
	}

	comment := lookupComment(path, fileDescriptor.SourceCodeInfo)
	if comment != "" {
		fmt.Fprintf(outFile, "%s// %s\n", indent(level), comment)
	}
}

// lookupComment searches the sourceInfo locations for one whose Path matches the given path.
// It returns any leading comments (or, if absent, trailing comments) attached to that element.
func lookupComment(path protoPath, sourceInfo *descriptorpb.SourceCodeInfo) string {
	if sourceInfo == nil {
		return ""
	}
	for _, loc := range sourceInfo.Location {
		if equalPath(loc.Path, path) {
			comment := strings.TrimSpace(loc.GetLeadingComments())
			if comment == "" {
				comment = strings.TrimSpace(loc.GetTrailingComments())
			}
			return comment
		}
	}
	return ""
}

// indent returns a string of spaces for indentation.
func indent(level int) string {
	return strings.Repeat("  ", level)
}

// printMessage prints a message definition following the desired format.
// It handles scalar fields, nested message fields, and enum fields.
// {/*msg *descriptorpb.DescriptorProto, path protoPath, ) {*/
func printMessage(ctx context.Context, outFile *os.File, msgKey string, level int) {
	protoIndexes := ctx.Value(protoIndexKey).(*protoIndex)

	msgMetadata := protoIndexes.messageIndex[msgKey]
	msg := msgMetadata.descriptor
	path := msgMetadata.path

	// If there is a comment on the message, print it.
	printCommentIfAny(outFile, msgMetadata.fileDescriptor, path, level)

	fmt.Fprintf(outFile, "%s%s {\n", indent(level), msg.GetName())

	// For each field in the message:
	for i, field := range msg.Field {
		// For a field, the path is the message's path plus [2, field_index] (2 = message.field)
		fieldPath := append(append([]int32(nil), path...), 2, int32(i))
		// (A complete implementation would derive the path based on the descriptor structure.)
		printCommentIfAny(outFile, msgMetadata.fileDescriptor, fieldPath, level+1)

		// Depending on field type and label, print accordingly.
		if field.GetLabel() == descriptorpb.FieldDescriptorProto_LABEL_REPEATED {
			// For repeated fields, use square brackets.
			fmt.Fprintf(outFile, "%s%s [\n", indent(level+1), field.GetName())
			// If the field is a message, print its definition inline.
			if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				typeName := field.GetTypeName()
				if _, ok := protoIndexes.messageIndex[typeName]; ok {
					printMessage(ctx, outFile, typeName, level+2)
					// Optionally print a comment for the field if available.
					//if nestedPath, ok := protoPathIndex[typeName]; ok {
					//	printMessage(outFile, m, nestedPath, level+2)
					//} else {
					//	printMessage(outFile, m, nil, level+2)
					//}
				}
			} else if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
				typeName := field.GetTypeName()
				if _, ok := protoIndexes.enumIndex[typeName]; ok {
					printEnum(ctx, outFile, typeName, level+2)
					//if enumPath, ok := protoPathIndex[typeName]; ok {
					//	printEnum(ctx, outFile, e, enumPath, level+2)
					//} else {
					//	printEnum(ctx, outFile, e, nil, level+2)
					//}
				}
			}
			fmt.Fprintf(outFile, "%s]\n", indent(level+1))
		} else {
			// For non-repeated fields, if the type is a message or enum, print inline.
			if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				typeName := field.GetTypeName()
				fmt.Fprintf(outFile, "%s%s %s {\n", indent(level+1), field.GetName(), typeName)
				if _, ok := messageIndex[typeName]; ok {
					printMessage(ctx, outFile, typeName, level+2)
					//if nestedPath, ok := protoPathIndex[typeName]; ok {
					//	printMessage(outFile, m, nestedPath, level+2)
					//} else {
					//	printMessage(outFile, m, nil, level+2)
					//}
				}
				fmt.Fprintf(outFile, "%s}\n", indent(level+1))
			} else if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM {
				typeName := field.GetTypeName()
				typeNameSplit := strings.Split(typeName, ".")
				readableTypeName := typeNameSplit[len(typeNameSplit)-1]
				fmt.Fprintf(outFile, "%s%s %s {\n", indent(level+1), "ENUM", readableTypeName)
				if _, ok := protoIndexes.enumIndex[typeName]; ok {
					printEnum(ctx, outFile, typeName, level+2)
					//if enumPath, ok := protoPathIndex[typeName]; ok {
					//	printEnum(ctx, outFile, e, enumPath, level+2)
					//} else {
					//	printEnum(ctx, outFile, e, nil, level+2)
					//}
				}
				fmt.Fprintf(outFile, "%s}\n", indent(level+1))
			} else {
				humeanReadableTypeSplit := strings.Split(field.GetType().String(), "_")
				humanReadableTypeName := humeanReadableTypeSplit[len(humeanReadableTypeSplit)-1]
				fmt.Fprintf(outFile, "%s%s %s\n", indent(level+1), humanReadableTypeName, field.GetName())
			}
		}
	}

	fmt.Fprintf(outFile, "%s}\n", indent(level))
}

// printEnum prints an enum definition with its values and comments.
// enum *descriptorpb.EnumDescriptorProto, path protoPath,
func printEnum(ctx context.Context, outFile *os.File, key string, level int) {
	protoIndexes := ctx.Value(protoIndexKey).(*protoIndex)
	enumMetadata := protoIndexes.enumIndex[key]
	enum := enumMetadata.descriptor
	path := enumMetadata.path

	// Optionally print a comment for the enum.
	printCommentIfAny(outFile, enumMetadata.fileDescriptor, path, level)
	for i, value := range enum.Value {
		// For an enum value, the path is the enum's path plus [2, value_index] (2 = enum.value)
		valuePath := append(append([]int32(nil), path...), 2, int32(i))
		printCommentIfAny(outFile, enumMetadata.fileDescriptor, valuePath, level)
		fmt.Fprintf(outFile, "%s%s", indent(level), value.GetName())
		fmt.Fprintln(outFile)
	}
}

// entrypoint is any message that doesn't appear in other fields (or types?)
func findEntrypoints() []string {
	// Create a set to track used message types.
	used := make(map[string]bool)

	// Iterate through all messages in the messageIndex.
	for _, msg := range messageIndex {
		// Process fields in this message.
		for _, field := range msg.Field {
			if field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE {
				// Mark the type as used. The field type name should be fully qualified.
				used[field.GetTypeName()] = true
			}
		}
	}

	// Now, any message in messageIndex that isn't in the 'used' map is an entry point.
	var entrypoints []string
	for name := range messageIndex {
		if !used[name] {
			entrypoints = append(entrypoints, name)
		}
	}
	return entrypoints
}

func indexNestedMessages(ctx context.Context, parent string) {
	protoIndexes := ctx.Value(protoIndexKey).(*protoIndex)

	if msgMetadata, ok := protoIndexes.messageIndex[parent]; ok {
		parentPath := msgMetadata.path
		parentFile := msgMetadata.fileDescriptor
		for j, nested := range msgMetadata.descriptor.NestedType {
			fqName := parent + "." + nested.GetName()
			nestedPath := append(append([]int32(nil), parentPath...), 3, int32(j))
			protoIndexes.addMessage(fqName, nestedPath, parentFile, nested)
			indexNestedMessages(ctx, fqName)
		}

		for j, enum := range msgMetadata.descriptor.EnumType {
			fqName := parent + "." + enum.GetName()
			enumPath := append(append([]int32(nil), parentPath...), 3, int32(j))
			protoIndexes.addEnum(fqName, enumPath, parentFile, enum)
		}
	}

}

// indexNestedMessages recursively indexes nested message types.
func indexNestedMessages2(parent string, msg *descriptorpb.DescriptorProto, parentFile *descriptorpb.FileDescriptorProto, parentPath []int32, protoIndexes *protoIndex) {
	for j, nested := range msg.NestedType {
		fqName := parent + "." + nested.GetName()
		messageIndex[fqName] = nested
		nestedPath := append(append([]int32(nil), parentPath...), 3, int32(j))
		protoPathIndex[fqName] = nestedPath
		protoIndexes.addMessage(fqName, nestedPath, parentFile, nested)
		indexNestedMessages2(fqName, nested, parentFile, nestedPath, protoIndexes)
	}
	// Also index any enums nested in this message.
	for j, enum := range msg.EnumType {
		fqName := parent + "." + enum.GetName()
		enumPath := append(append([]int32(nil), parentPath...), 4, int32(j))
		enumIndex[fqName] = enum
		protoPathIndex[fqName] = enumPath
		protoIndexes.addEnum(fqName, enumPath, parentFile, enum)
	}
}

// equalPath compares two slices of int32 for equality.
func equalPath(a, b protoPath) bool {
	if len(a) != len(b) {
		return false
	}
	for i, v := range a {
		if b[i] != v {
			return false
		}
	}
	return true
}
