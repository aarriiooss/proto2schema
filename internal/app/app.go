package app

import (
	"io"
	"log"
	"os"
	"strings"

	"proto2schema/internal/converter"
	"proto2schema/internal/index"
	"proto2schema/internal/writer"

	"google.golang.org/protobuf/proto"
	"google.golang.org/protobuf/types/descriptorpb"
	"google.golang.org/protobuf/types/pluginpb"
)

// RunStandalone runs the converter in standalone mode
func RunStandalone(descriptorPath string, outPath string) {
	logger := log.New(os.Stdout, "", log.LstdFlags|log.Lmicroseconds|log.Lshortfile)

	logger.Println("Attempting to read binbp")
	// Read the file descriptor set generated by protoc.
	data, err := os.ReadFile(descriptorPath)
	if err != nil {
		logger.Fatalf("Failed to read descriptor set: %v", err)
	}
	logger.Printf("Read descriptor set: %s", descriptorPath)

	// Unmarshal the data into a FileDescriptorSet.
	var fds descriptorpb.FileDescriptorSet
	if err := proto.Unmarshal(data, &fds); err != nil {
		logger.Fatalf("Failed to unmarshal descriptor set: %v", err)
	}
	logger.Println("Unmarshalled descriptor set.")

	pIndex := index.BuildProtoIndex(fds.File)

	logger.Println("finish parsing descriptor set.")
	outFile, err := os.Create(outPath)
	schemaWriter := writer.NewCustomWriter(outFile, logger)
	if err != nil {
		logger.Fatalf("Failed to create output file: %v", err)
	}
	defer func(outFile *os.File) {
		err := outFile.Close()
		if err != nil {
			log.Fatal(err)
		}
	}(outFile)

	entryPoints := index.FindEntrypoints(pIndex.MessageIndex)

	for i, ep := range entryPoints {
		if _, ok := pIndex.MessageIndex[ep]; ok {
			converter.PrintMessage(pIndex, schemaWriter, ep, 0, make(map[string]bool))

			// make sure we have a blank line between top level messages
			if i != len(entryPoints)-1 {
				schemaWriter.WriteLine(0, "")
			}
		}
	}
}

// RunAsPlugin runs the converter as a protoc plugin
func RunAsPlugin(r io.Reader, w io.Writer) {
	// protoc plugins only read from stdin
	data, err := io.ReadAll(r)
	if err != nil {
		log.Fatalf("plugin: failed to read stdin: %v", err)
	}

	// CodeGeneratorRequest is slightly different than the data in .binpb files
	// data in .binpb seems like it's a subset of CodeGeneratorRequest but I don't
	// know the implications of converting yet
	var req pluginpb.CodeGeneratorRequest
	if err := proto.Unmarshal(data, &req); err != nil {
		log.Fatalf("plugin: failed to unmarshal CodeGeneratorRequest: %v", err)
	}

	pIndex := index.BuildProtoIndex(req.GetProtoFile())

	// This is what is sent back to protoc via stdout
	resp := &pluginpb.CodeGeneratorResponse{}

	// For each .proto that protoc asked you to generate,
	// find the matching FileDescriptorProto and produce one .fdhschema chunk.
	// In plugin mode, each file passed to protoc will be treated as a top level file
	// but no output file may be generated depending if the content of that proto
	// is already contained in another file (aka if file has no entryPoints
	for _, filename := range req.FileToGenerate {
		log.Printf("Plugin mode FileToGenerate: %s", filename)
		var fdProto *descriptorpb.FileDescriptorProto
		for _, f := range req.GetProtoFile() {
			if f.GetName() == filename {
				fdProto = f
				break
			}
		}
		// Is there ever a case where the FileDescriptor proto could not be found
		// in the same req?
		if fdProto == nil {
			continue
		}

		// Filter entrypoints that belong to this file
		var entriesForFile []string
		entryPoints := index.FindEntrypoints(pIndex.MessageIndex)
		for _, ep := range entryPoints {
			if meta, ok := pIndex.MessageIndex[ep]; ok && meta.FileDescriptor == fdProto {
				entriesForFile = append(entriesForFile, ep)
			}
		}

		log.Printf("Plugin mode FileToGenerate: %s with entriesForFile: %s", filename, entriesForFile)
		// Skip if this file has no entry points
		// no entry points means stuff defined in this file is contained in another file
		if len(entriesForFile) == 0 {
			log.Printf("Skipping: %s because file had no entry points", filename)
			continue
		}

		// in-memory buffer
		var buf strings.Builder
		schemaWriter := writer.NewCustomWriter(&buf, log.Default())

		for i, ep := range entriesForFile {
			converter.PrintMessage(pIndex, schemaWriter, ep, 0, make(map[string]bool))

			// make sure we have a blank line between top level messages
			if i != len(entriesForFile)-1 {
				schemaWriter.WriteLine(0, "")
			}
		}

		// Add content to response expected by protoc
		outName := strings.TrimSuffix(filename, ".proto") + ".fdhschema"
		resp.File = append(resp.File, &pluginpb.CodeGeneratorResponse_File{
			Name:    proto.String(outName),
			Content: proto.String(buf.String()),
		})
	}

	// Marshal & write the response to stdout
	outBytes, err := proto.Marshal(resp)
	if err != nil {
		log.Fatalf("plugin: failed to marshal CodeGeneratorResponse: %v", err)
	}
	if _, err := w.Write(outBytes); err != nil {
		log.Fatalf("plugin: failed to write response: %v", err)
	}
}
